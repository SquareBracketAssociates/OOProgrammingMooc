{
	"title":"About Static and Dynamic Types",
	"slidesid":"Core",
	"author":"S. Ducasse"
}


${slide:title=Objectives}$

- Understanding dynamic and static
- Be the basis for understanding the influence of type checking on method lookup
- And the interplay with Interfaces

${slide:title=Static vs. Dynamic Types}$

[[[
A a = new B();
]]]

- The static type of variable ==a== is ==A==  i.e., the statically declared class to which it belongs.
-- The static type never changes.

- The dynamic type of ==a== is ==B==  i.e., the class of the object currently bound to a.
-- The dynamic type may change throughout the program.


${slide:title=Static vs. Dynamic Types}$

[[[
A a = new B();
a = new A();
]]]

Now the dynamic type is also A!

${slide:title=Static vs. Dynamic Types}$

This works too with method signature
[[[
public class A { }
public class B extends A { }
]]]

[[[
	public class Main {
	    public static void main(String[] args) {
	        dynclassOutput (new B());
	        dynclassOutput (new A());
	    }
	    public static void dynclassOutput (A a) {
	        System.out.println(a.getClass().getName());
	    }
	}
]]]

What is the static / dynamic type of ==a== there?


${slide:title=Using types in method signature}$

You can have multiple methods with the same name and types argument
[[[
	visit(ProgramNode n) {}

	visit(Assignment n) {}
	
	visit(SequenceNode n) {}
]]]

- Don't use it!

${slide:title=Overloading is a bad idea}$

- Avoid it as much as possible... it makes code less extensible
- Overloading makes your code difficult to understand and extend in presence of subtyping
- But OOP is using subtyping: a subclass extends a superclass
- Check the other lectures


${slide:title=Kind of Summary}$

- Static types are known by the compiler. 
- Dynamic types are the variable values known at execution.

${slide:title=What you should know}$

- Dynamic / static types
- ==equals(Object o)==