{
	"title":"Key OO concepts in Java",
	"slidesid":"",
	"author":"S. Ducasse"
}


${slide:title=Objectives}$

- Illustrate key OO concepts
- In Java but limited as much as possible to the essential points

Thanks Alexandre Bergel for parts of the materials used in this lecture!

${slide:title=Quotes of the day}$

"Perfection is attained, not when no more can be added, but when no more can be removed." Antoine de Saint-Exup√©ry

"I invented the term 'Object-Oriented', and I can tell you I did not have C\+\+ in mind." Alan Kay
(nor Java :))


${slide:title=What we will not cover}$

- Java is gigantic and even more... (looks more and more like an old verbose language)
- Full of conceptual glitches (public fields, strange protected semantics, overloading...)
- This lecture will not cover packaging, enums, lambdas, generics, inner classes, modules, synchronised, meta data, primitives vs. boxed....
- Java mixes physical representation (files) with concepts 
-- there is not need to have files to have classes
-- class definitions can be saved in databases
- But we will provide extras slides on more advanced topics

${slide:title=Java}$

Not pure object-oriented programming language
- Static methods are not looked up
- Primitive types are not objects: int and Integer....
- Classes are not really accessible objects
- Methods


${slide:title=Outline}$

- Instances, instance creation
- Classes
- Methods
- Inheritance (single)
- 



${slide:title=Instances}$

- Created using ==new== construct
- Remember: one state, identity, behavior

[[[
new Tomagotchi()
]]]

Often 
[[[
Tomagotchi t = new Tomagotchi()
]]]


${slide:title=Class}$

- Mold/Generators of instances
[[[
public class Rectangle
	{
	    protected double length;
	    protected double width;
		...
]]]

[[[
public class Box extends Rectangle {
	    protected double height;
}
]]]

${slide:title=Class}$

- One public class per file
- File name should have the name of the public class
- Class import packages (group of classes)


${slide:title=Instance variables}$

- Describe instance structure
- Have a visibility: Avoid public, private and final :)
- Better use protected (see companion extra lectures)

[[[
public class Rectangle
	{
	    protected double length;
	    protected double width;
		...
]]]

- Accessible by method of the class and subclasses

${slide:title=Methods}$


==this== represents the receiver


${slide:title=Constructor I}$
- Responsible to properly initialize an object 

[[[
new JButton("Ok")
]]]

- Allocate and initialize a button
- ==<Class>()== is the default constructeur

${slide:title=Rectangle Constructors}$

[[[
	public Rectangle() {
       length = 0;
       width = 0;
    }

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
]]]



${slide:title=Lookup}$

- Lookup of a method always starts in the class of the receiver
- 





There is no lookup for private method.




${slide:title=Lookup}$

[[[
class A {
    public int f() { return g();}
    public int g() {
        System.out.println("A");
        return 1;
    }
}
class B extends A {
    public int g() {
        System.out.println("B");
        return 2;
    }
}

class Runner {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        a.f();
        b.f();
    }
}
]]]

We will revisit it in the self (this)/super lecture...













${slide:title=Lookup with Super}$

[[[
class A {
  public void f() { g(); }
  public void g() { print("A"); }
}
class B extends A {
  public void f() { super.f(); }
  public void g() { print("B"); }
}
]]]
[[[
(new A()).f();
(new B()).f();
]]]

${slide:title=super in super.myMethod(); }$

- super refers to the object the receiver of the message
-- super \=\= this
- super changes the method lookup to start in the superclass of the class using super. 
- super does not start lookup in the superclass of the class of the receiver



${slide:title=Inheritance}$

[[[
class Box extends Rectangle{ 
	protected double height;

}
]]]

${slide:title=Box constructors}$

[[[
	public Box(){
        super();
        height = 0;
    }
]]]

[[[
    public Box(double length, double width, double height) {
        super(length, width);
        this.height = height;
	}
]]]

${slide:title=Constructors and inheritance}$

- Each subclass should call its superclass constructor explicitly 
-- as a first line of the constructor
- The call to the default constructor can be omitted (but the compiler does it for you)
- ==super== in that case indicate the superclass.
- There is NO LOOKUP/Inheritance of constructor


${slide:title=Constructor II}$

[[[
public JButton() {
        this(null, null);
}
]]]


[[[
public JButton(String text) {
        this(text, null);
]]]


[[[
public JButton(String text, Icon icon) {
        setModel(new DefaultButtonModel());
        init(text, icon);
    }
]]]

- Constructors may invoke each other. 
- The keyword this is used for that purpose. 
Note that this ==this==, used in to invoke constructor, has nothing to do with the ==this== pseudo variable used in method.


${slide:title=Constructor III}$

Example here


${slide:title=Constructors are not inherited}$


${columns}$

${column:width=50}$

[[[
new Point()
new Point(2, 3)
=> Okay
]]]

[[[
new ColorPoint()
=> Okay (because of the 
default constructor)

new ColorPoint(2, 3)
=> Does not compile
]]]

${column:width=50}$

+>file://figures/PointInheritance.png|width=86+

${endColumns}$


${slide:title=Missing default constructor}$


${columns}$

${column:width=50}$

[[[
new Point()
new Point(2, 3)
=> Okay
]]]

[[[
new ColorPoint()
=> Does not compile 
(because there is no 
default constructor)

new ColorPoint(2, 3)
=> Okay
]]]

${column:width=50}$

+>file://figures/PointInhMissingDefault.png|width=86+

${endColumns}$



${slide:title=Constructors}$

[[[
class Rectangle {
	   protected double length; protected double width;
	   public Rectangle(){
	      length = 0;
	      width = 0; }
	   public Rectangle(double length, double width) {
	         this.length = length;
	         this.width = width; }
]]]

[[[
class Box extends Rectangle {
	   protected double height;
	   public Box() { 
	       super();
	       height = 0; 
	   }
	   public Box(double length, double width, double height) {
	         super(length, width);
	         this.height = height; 
		}
]]]


${slide:title=About implicit constructor invocation}$

[[[
class Super {
    String s;
    public Super(){ System.out.println("Super"); }
}
 
public class Sub extends Super { 
    public Sub(){ 
		super (); // implicitly added if not present
		System.out.println("Sub"); }
    public static void main(String[] args){
    	Sub s = new Sub(); }
}

>>> Super
>>> Sub
]]]

- If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. 
- If the super class does not have a no-argument constructor, you will get a compile-time error. Object does have such a constructor, so if Object is the only superclass, there is no problem.
- The rules is: subclass constructor has to invoke super class constructor, either explicitly by programmer or implicitly by compiler. For either way, the invoked super constructor has to be defined.

${slide:title=Example of missing super constructor }$

"Implicit super constructor is undefined for default constructor. Must define an explicit constructor"

[[[
class Super {
    String s;
    public Super(String s) { this.s = s; }
}

public class Sub extends Super { 
    public Sub(){ 
		System.out.println("Sub"); }

    public static void main(String[] args){
    	Sub s = new Sub(); }
}
]]]


${slide:title=Static variables or methods }$

- Modifier 'static'
- Linked to the class
- No lookup for static methods
- Variable unique and shared between all instances of the class
- Kind of global since the class is a global too

[[[
class Circle {
	static double PI = 3.14159265; 
	double rayon; //instance level
	double circonference() {
		return 2*PI*rayon; // or Circle.PI
		}
	}
]]]





${slide:title=Interfaces}$

- Group of method signatures
- Used by the type checker 
- Support the manipulation of instances of classes not in subtype relation (i.e. not in the same hierachy)

[[[
interface {
	//methods
}
]]]



${slide:title=Example}$

All methods are implicitly public and all fields are public static final.
[[[
interface Polygon {
   public static final String color = "blue";
  
   public  void getArea();
}
]]]

[[[
interface Polygon {
  String color = "blue";
  
  void getArea();
}
]]]

${slide:title=Example}$

[[[
class Rectangle implements Polygon {
	... 
    public void getArea() {
        System.out.println("The area of the rectangle is " + (length * width));
    }
}
]]]

Any class implementing an interface MUST defined the methods specified in the interface,

${slide:title=Classes - Interfaces}$

- A class can implement many interfaces
- A class inherits from a single superclass

- An interface can "inherit" from multiple interfaces
-- compose interfaces

${slide:title=Interfaces: step back}$

 A nice mechanism for statically check language
- defined what is expected
- let the system evolve

When you use a class as a type
- You freeze the possible instances
- You will only be able to have instances of type or subtypes

When you use an interface as a type
- You will be able to use any instance of classes implementing the interface



${slide:title=Outline...}$

${slide:title=Super well which one...}$
Java is confusing at wish:

- ==super== in accessing super same named superclass fields (Duh! Ugly)
-- Syntactically: ==super.x==
- ==super== in method to invoke overridden super method (super is the receiver see Lecture)
-- Syntactically: ==super.method();==
- ==super== in constructor 
-- Syntactically: ==super(x)==
-- first line represents the superclass and looks for constructor function based on argument
-- in any for the other line, represents the newly created object but changes lookup and in plain method.
- ==static <T> void copy(List<? super T> dest, List<? extends T> src)==
-- to say any super type of T.
-- well

${slide:title=Super : accessing super same named superclass fields}$

[[[
class Vehicle { 
    int maxSpeed = 120; 
} 

class Car extends Vehicle { 
    int maxSpeed = 180; 
  
    void display() { 
        System.out.println("Maximum Speed: " + super.maxSpeed); 
    } 
}
class Test { 
    public static void main(String[] args) { 
        Car small = new Car(); 
        small.display(); 
    } 
} 
>>> 120  
]]]
- Do not redefine fields in subclass with the same name... 
- The language should not let you do that!

${slide:title=super in constructors}$

- means look in superclass and invoke the constructor with the same signature as the super call

[[[
public Meal {
    public Meal(String flavour) {
       this.flavour = flavour;
    }
}
]]]

[[[
public Crisps(String flavour, int quantity) {
    super(flavour); // pass flavour to the super class constructor
    this.quantity = quantity;
}
]]]

${slide:title=super in constructor: II }$

[[[
public Meal {
	public void setFlavour(String flavour) {
	    this.flavour = flavour;
	}
]]]

[[[
public Crisps(String flavour, int quantity) {
    this.quantity = quantity;
    super.setFlavour(flavour);
}
]]]

Clearly not good style. But super here is not the superclass but the instance. 



${slide:title=About main and command line}$

- one single parameter: a table of strings
- argv.length 
[[[
public class Echo {
	public static void main(String[] argv) { 
		for (int i=0; i<argv.length; i++)
			System.out.print(argv[i]+" ");
			System.out.println(); }
	}
>>>java Echo OOP is COOL, Java less
>>>OOP is COOL, Java less
]]]






${slide:title=What you should know}$

- What is a unit test
- Writing a test
- What is pass, failed, errors
- Tests are your best friends against bugs and evolution