{
	"title":"Some type aspects of Java",
	"slidesid":"",
	"author":"S. Ducasse"
}


${slide:title=Objectives}$

- Understanding dynamic and static
- Casts 

${slide:title=Static vs. Dynamic Types}$

[[[
A a = new B();
]]]

- The static type of variable a is A  i.e., the statically declared class to which it belongs.
-- The static type never changes.

- The dynamic type of a is B  i.e., the class of the object currently bound to a.
-- The dynamic type may change throughout the program.

[[[
a = new A();
]]]

Now the dynamic type is also A!

${slide:title=Static vs. Dynamic Types}$

This works too with method signature

[[[
	myMethod(A a){
	
	}
	
	myMethod(new B());
	myMethod(new A());
]]]


${slide:title=Overloading...}$

You can have multiple methods with the same name and types argument
[[[
	visit (ProgramNode n) {}

	visit (Assignment n) {}
	
	visit (SequenceNode n) {}
]]]

- Avoid it as much as possible


${slide:title=Avoid overloading}$
Overloading: multiple methods with the same name but different types is a recipe to disaster.

- Overloading makes your code difficult to understand in presence of subtyping
- Programming in OOP is using subtyping 
- Overloading makes code less extensible
- Check other lectures


${slide:title=About Casts}$

- Casts never change program execution
- Casts are only useful to indicate to the compiler that a reference to a supertype (think Train) is an instance of a wellknow subtype (TGV)
- Cast to a super type are useless because a subtype is a subtype (if we expect Train we can get TGV already)

${slide:title=Kind of Summary}$

- Static types are known by the compiler. 
- Dynamic types are the variable values known at execution.


${slide:title=Method lookup}$

- The compiler choses one signature (with static types)
- The runtime uses dynamic types and looks for a method compatible with the signature




${slide:title=What you should know}$

- What is a unit test
- Writing a test
- What is pass, failed, errors
- Tests are your best friends against bugs and evolution