{
	"title":"Unit testing",
	"slidesid":"",
	"author":"S. Ducasse"
}


${slide:title=Objectives}$

- Examples of Unit tests
- Core concepts 
- In Java, C#, PHP and Pharo

Thanks Alexandre Bergel for parts of the materials used in this lecture!

${slide:title= SUnit -> JUnit3}$

- Originally developed by K. Beck (agile programming father)
- Extremely simple (4 classes)
- Got copied all over the places: JUnit3.x, PHPUnit,...


${slide:title=A Test}$

In a test, we 
- Create a context: Create an empty set
- Send a stimulus: Add twice the same element
- Check the results: Check that the set contains only one element

${slide:title=Set TestCase}$

[[[
TestCase subclass: # SetTest
    ...
]]]

[[[
SetTest >> testAdd 
  | empty |
  empty := Set new.   "Context"
  empty add: 5.   "Stimulus"
  empty add: 5.
  self assert: empty size = 1.   "Check"
]]]

${slide:title=Another example: CounterTest}$

[[[
TestCase subclass: # CounterTest
    ...
]]]

[[[
CounterTest >> testIncrement 
  | counter |
  counter := Counter new.   "Context"
  counter value: 22. 
  counter increment.   "Stimulus"
  counter increment.
  self assert: count value equals: 24.   "Verification"
]]]

${slide:title=JCounter }$

[[[
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

class CounterTest {

  @Test
  public void testConstructorIsInitializing()  {
      assertEquals(new Counter().value(), 0);
  }

  @Test
  public void testIncrement() {
       Counter count = new Counter();
       count.setValue(22);
       count.increment();
       count.increment();
       assertEquals(count.value(),24 );
   }
}
]]]



${slide:title=Success, Failures and Errors}$

- Success: a test passes
- A failure is a failed assertion, i.e., an anticipated problem that you test.
- An error is a condition you didn’t check for, i.e., a runtime error.

${slide:title=Concepts}$

+>file://figures/Junit3.png|width=80+


${slide:title=Unit Frameworks}$

- JUnit is based on SUnit 
- Test-Driven Development, by Kent Beck


${slide:title=JUnit 3.x is similar to Pharo 3.0}$

[[[
	import junit.framework.*;
	public class MoneyTest extends TestCase {
		private Money f12CHF;			// fixtures
		private Money f14CHF;

		protected void setUp() {		// create the test data
			f12CHF = new Money(12, "CHF");
			f14CHF = new Money(14, "CHF");
		}
	   public void testAdd() {				// create the test data
			Money expected = new Money(26, “CHF”);
			assertEquals(“amount not equal”,
	                     expected, f12CHF.add(f14CHF));
		}
		...
	}
]]]

${slide:title=PHPUnit is closed to JUnit 3/Pharo}$

[[[
<?php
class MoneyTest extends PHPUnit_Framework_TestCase
{
    // ...
    public function testCanBeNegated()
    {
        // Arrange
        $a = new Money(1);

        // Act
        $b = $a->negate();

        // Assert
        $this->assertEquals(-1, $b->getAmount());
    }
    // ...
}
]]]


${slide:title=In Ruby}$
[[[
# File:  tc_simple_number2.rb

require_relative "simple_number"
require "test/unit"

class TestSimpleNumber < Test::Unit::TestCase

  def test_simple
    assert_equal(4, SimpleNumber.new(2).add(2) )
    assert_equal(4, SimpleNumber.new(2).multiply(2) )
  end
 
  def test_typecheck
    assert_raise( RuntimeError ) { SimpleNumber.new('a') }
  end
 
  def test_failure
    assert_equal(3, SimpleNumber.new(2).add(2), "Adding doesn't work" )
  end

end
]]]

${slide:title=JUnit 4 based on annotations}$

- J2SE 5 introduces the Metadata feature (data about data)
- Annotations allow you to add decorations to your code (remember javadoc tags: @author ) 
- Annotations are used for code documentation, compiler processing (@Deprecated ), code generation, runtime processing
*http://java.sun.com/docs/books/tutorial/java/javaOO/annotations.html*


${slide:title=JUnit 4.x}$

- Annotations for marking methods as tests (@Test)
- Annotations for marking methods that setting up and cleaning up “fixtures” (@Before) 
- methods for making assertions assertEquals()

${slide:title=JUnit 4.x Example Code}$

[[[
import org.junit.*;
import static org.junit.Assert.*; 
public class MoneyTest {
	private Money f12CHF;
	private Money f14CHF;

	@Before public void setUp() {	// the fixture
		f12CHF = new Money(12, "CHF");      
		f14CHF = new Money(14, "CHF");
	}
	
	@Test public void add() {
		Money expected = new Money(26, “CHF”);
		assertEquals(“amount not equal”,
                     expected,f12CHF.add(f14CHF));
	}
	...
}
]]]

${slide:title=In C#}$

[[[
[TestMethod]
public void Withdraw_ValidAmount_ChangesBalance()
{
    // arrange
    double currentBalance = 10.0;
    double withdrawal = 1.0;
    double expected = 9.0;
    var account = new CheckingAccount("JohnDoe", currentBalance);
    // act
    account.Withdraw(withdrawal);
    double actual = account.Balance;
    // assert
    Assert.AreEqual(expected, actual);
}

[TestMethod]
[ExpectedException(typeof(ArgumentException))]
public void Withdraw_AmountMoreThanBalance_Throws()
{
    // arrange
    var account = new CheckingAccount("John Doe", 10.0);
    // act
    account.Withdraw(1.0);
    // assert is handled by the ExpectedException
}
]]]


${slide:title=3 Testing practices}$
- During dev, write tests first
-- Specify what you want
-- You are done when the tests run
- When you redesign/improve your software
-- refactor in small steps and 
-- run the tests to stop any regression
-- fix what is broken (get the bar green)
- During debugging
-- write a test that demonstrates the bug
-- then fix it.