{
	"title":"Key OO concepts in Java",
	"slidesid":"",
	"author":"S. Ducasse"
}


${slide:title=Objectives}$

- Illustrate key OO concepts
- In Java but limited as much as possible to the essential points

Thanks Alexandre Bergel for parts of the materials used in this lecture!

${slide:title=What we will not cover}$

- Java is gigantic and even more...
- Full of conceptual glitches (public fields, strange protected...)
- This lecture will not cover packaging, lambdas, generics, inner classes,  synchronised, meta data, 
- Provide some extras slides on more advanced topics

${slide:title=Java}$

Not pure object-oriented programming language
- Static methods are not looked up
- Primitive types are not objects
- Classes are not really accessible objects
- Methods 


${slide:title=Objects}$

Created using ==new== construct

[[[
new Tomagotchi()
]]]

Now 

[[[
Tomagotchi t = new Tomagotchi()
]]]


${slide:title=Class}$

[[[


]]]

${slide:title=Class}$

- One public class per file
- File name should have the name of the public class




${slide:title=Instance variables}$




${slide:title=Methods}$

==this== represents the receiver


${slide:title=Constructor I}$
- Responsible to properly initialize an object 

[[[
new JButton("Ok")
]]]
- Allocate and initialize a button

- ==<Class>()== is the default constructeur
- 

${slide:title=Example Rectangle}$

[[[
class Rectangle{ 
	Point origin, corner;

}
]]]

${slide:title=Inheritance}$



${slide:title=Lookup}$

[[[
class A {
    public int f() { return g();}
    public int g() {
        System.out.println("A");
        return 1;
    }
}
class B extends A {
    public int g() {
        System.out.println("B");
        return 2;
    }
}

class Runner {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();
        a.f();
        b.f();
    }
}
]]]

We will revisit

${slide:title=Lookup with Super}$

[[[
class A {
  public void f() { g(); }
  public void g() { print("A"); }
}
class B extends A {
  public void f() { super.f(); }
  public void g() { print("B"); }
}
]]]
[[[
(new A()).f();
(new B()).f();
]]]



${slide:title=Constructor II}$

[[[
public JButton() {
        this(null, null);
}
]]]


[[[
public JButton(String text) {
        this(text, null);
]]]


[[[
public JButton(String text, Icon icon) {
        // Create the model
        setModel(new DefaultButtonModel());
        // initialize
        init(text, icon);
    }
]]]
- Constructors may invoke each other. 
-- The keyword this is used for that purpose. Note that this ==this==, used in to invoke constructor, has nothing to do with the ==this== pseudo variable used in method.





${slide:title=Constructor III}$

Example here

- Superclass constructors are sequentially executed

${slide:title=Constructors are not inherited}$


${columns}$

${column:width=50}$

[[[
new Point()
new Point(2, 3)
=> Okay
]]]

[[[
new ColorPoint()
=> Okay (because of the 
default constructor)

new ColorPoint(2, 3)
=> Does not compile
]]]

${column:width=50}$

+>file://figures/PointInheritance.png|width=86+

${endColumns}$


${slide:title=Missing default constructor}$


${columns}$

${column:width=50}$

[[[
new Point()
new Point(2, 3)
=> Okay
]]]

[[[
new ColorPoint()
=> Does not compile 
(because there is no 
default constructor)

new ColorPoint(2, 3)
=> Okay
]]]

${column:width=50}$

+>file://figures/PointInhMissingDefault.png|width=86+

${endColumns}$



${slide:title=Constructors}$

[[[
class Rectangle {
	   protected double length; protected double width;
	   public Rectangle(){
	      length = 0;
	      width = 0; }
	   public Rectangle(double length, double width) {
	         this.length = length;
	         this.width = width; }
]]]

[[[
class Box extends Rectangle {
	   protected double height;
	   public Box() { 
	       super();
	       height = 0; 
	   }
	   public Box(double length, double width, double height) {
	         super(length, width);
	         this.height = height; 
		}
]]]

${slide:title=super in constructors}$

- means look in superclass and invoke the constructor with the same signature as the super call

[[[
public Meal {
    public Meal(String flavour) {
       this.flavour = flavour;
    }
}
]]]

[[[
public Crisps(String flavour, int quantity) {
    super(flavour); // send flavour to the super class constructor
    this.quantity = quantity;
}
]]]

${slide:title=super in constructor: II }$

[[[
public Meal {
	public void setFlavour(String flavour) {
	    this.flavour = flavour;
	}
]]]

[[[
public Crisps(String flavour, int quantity) {
    this.quantity = quantity;
    super.setFlavour(flavour);
}
]]]

${slide:title=About implicit constructor invocation}$

[[[
class Super {
    String s;
    public Super(){ System.out.println("Super"); }
}
 
public class Sub extends Super { 
    public Sub(){ 
		super (); // implicitly added if not present
		System.out.println("Sub"); }
    public static void main(String[] args){
    	Sub s = new Sub(); }
}

>>> Super
>>> Sub
]]]

- If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. 
- If the super class does not have a no-argument constructor, you will get a compile-time error. Object does have such a constructor, so if Object is the only superclass, there is no problem.
- The rules is: subclass constructor has to invoke super class constructor, either explicitly by programmer or implicitly by compiler. For either way, the invoked super constructor has to be defined.

${slide:title=Example of missing super constructor }$

"Implicit super constructor is undefined for default constructor. Must define an explicit constructor"

[[[
class Super {
    String s;
    public Super(String s) { this.s = s; }
}

public class Sub extends Super { 
    public Sub(){ 
		System.out.println("Sub"); }

    public static void main(String[] args){
    	Sub s = new Sub(); }
}

]]]

${slide:title=Static variables or methodes }$

- Modifier 'static'
- Linked to the class
- No lookup for static methods
- Variable unique and shared between all instances of the class
- Kind of global since the class is a global too

[[[
class Circle {
	static double PI = 3.14159265; 
	double rayon; //instance level
	double circonference() {
		return 2*PI*rayon; // or Circle.PI
		}
	}
]]]


${slide:title=About main and command line}$

- one single parameter: a table of strings
- argv.length 
[[[
public class Echo {
	public static void main(String[] argv) { 
		for (int i=0; i<argv.length; i++)
			System.out.print(argv[i]+" ");
			System.out.println(); }
	}
>>>java Echo OOP is COOL, Java less
>>>OOP is COOL, Java less
]]]


${slide:title=Super well which one...}$
Java is confusing at wish:

- super in accessing super same named superclass fields (Duh! Ugly)
- super in method to invoke overridden super method (super is the receiver see Lecture)
- super in constructor 
-- first line represents the superclass and looks for constructor function based on argument
-- in any for the other line, represents the newly created object but changes lookup and in plain method.

${slide:title=Super : accessing super same named superclass fields}$


[[[
class Vehicle { 
    int maxSpeed = 120; 
} 

class Car extends Vehicle { 
    int maxSpeed = 180; 
  
    void display() { 
        System.out.println("Maximum Speed: " + super.maxSpeed); 
    } 
}
class Test { 
    public static void main(String[] args) { 
        Car small = new Car(); 
        small.display(); 
    } 
} 
>>> 120  
]]]
- Do not redefine fields in subclass with the same name... 
- The language should not let you do that!


${slide:title=What you should know}$

- What is a unit test
- Writing a test
- What is pass, failed, errors
- Tests are your best friends against bugs and evolution