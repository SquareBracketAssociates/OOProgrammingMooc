! Pharo / Java / C++ syntax comparison!! Basics of Syntax - Types of Messages!!! unary messages - messages without argumentsST[[[language=smalltalklist removeAll.]]]Java[[[language=javalist.clear();]]]!!!! messages on numbersST[[[language=smalltalk7 isPrime.7 asString.]]]Java[[[language=javaint x = 7;(new Integer(x)).toString();]]]In Java primitive types (int, float, ...) are not actually objects, but primitive types. To call methods on them, they must be boxed to classes.!!! binary messages - messages named with special symbol and a single argument- Note: binary messages are evaluated left to right without any changes based on the symbols used.ST[[[language=smalltalk2 + 3. "-> 5"2 + 3 * 6. "-> 30" "no special priorities!""(2.plus(3)).times(6)"2 + (3 * 6). "-> 20""(2.plus(3.times(6)))"]]]No special syntax to define binary messages.ST[[[language=smalltalkDiceBag>>+ aDie	dice add: aDie]]]Java[[[language=java// not possible]]]C++[[[language=cppclass DiceBag {	DiceBag operator+(const Die& die) {		dice.push_back(die);		return this;	}}]]]Note that overloaded C++ operators still follow Math precedence, which doesn't necessarily make sense in a general context.!!! keyword messages - word messages with multiple argumentsST[[[language=smalltalklist add: 12. "the message is `add:` with argument 12"dictionary at: 'key' put: 'value'. "the message is `at:put:` with arguments 'key' and 'value'"3 between: 1 and: 10. "message is `between:and:` with arguments 1 and 10 send to the object 3"]]]Java[[[language=javalist.add(12);dictionary.put("key", "value"); // easy to swap arguments by mistake(new Integer(3)).between(1, 10); // assuming such method would exist]]]!!! Message Priorityparentheses > unary > binary > keywordTake care when writing embedded keyword messages:without parentheses[[[language=smalltalkdictionary at: dictionary at: 'key' put: 12."sending non-existing message `at:at:put:`"]]]- a non-existing message ==at:at:put:== will be sent with arguments ==dictionary==, =='key'==, and ==12==with parentheses[[[language=smalltalkdictionary at: (dictionary at: 'key') put: 12.]]]- first the inner send will be evaluated (==dictionary at: 'key'==)- then the outer send will be evaluated (==dictionary at: valueFromAbove put: 12==)!! Basics of Syntax - Syntax Constructs- every statement terminated with a ==.== dot, equivalent to a a ==;== semicolon in Java.ST[[[language=smalltalkvar := 1 + 1.]]]Java[[[language=javaint var = 1 + 1.			]]]- assignment ==:\===- equality by value ==\=== (non-equality ==~\===) (do they have the same value?)- equality by identity ==\=\=== (non-equality ==~~==) (are they the same object?)[[[language=smalltalka := 'hello'.b := 'hello'.a = b. "-> true; same value"a == b. "-> false ; different objects"]]]- string in single quotes, two single quotes for escaping[[[language=smalltalka := 'string'. "-> string"a := 'hello ''world'''. "-> hello 'world'"]]]- comments in double quotes, two double quotes for escaping[[[language=smalltalk"I am a ""comment"""]]]!! Basics of Syntax - BlocksIn other languages also known as anonymous functions, closures, or lambda expressions (note: there are some differences between them, but that's outside of this piece)We pass a function, or a deferred computation as an argument.ST[[[language=smalltalk"declaration of a block; the result will be the last statement within the block"msg0 := [ 'hello ' repeat: 2 ].msg1 := [ :arg1 | arg1 + 10 ].msg2 := [ :arg1 :arg2 | arg1 + arg2 ].msg3 := [ :arg | |localVar1 localVar2|	localVar1 := arg + 1.	localVar2 := localVar1 + 2.	localVar2]."evaluation"msg0 value. "-> 'hello hello '"msg1 value: 2. "-> 12"msg2 value: 2 value: 3. "-> 5"msg3 value: 0. "-> 3"]]]JavaScript[[[language=javascriptvar msg3 = function(arg) {	var localVar1 = arg + 1;	var localVar2 = localVar + 2;	return localVar2;};msg3(0); // -> 3]]]Java[[[language=javaclass Msg3 {	public int value(int arg) {		int localVar1 = arg + 1;		int localVar2 = arg + 2;		return localVar2;		}}(new Msg3()).value(0); // -> 3]]]Using blocks as CallbacksST[[[language=smalltalk			transformText := [ :text :callback | |result|	result := text asUppercase.	callback value: result value: text.].transformText value: 'hello' value: [ :newText :originalText |	"newText = 'HELLO'"	"originalText = 'hello'"].]]]JavaScript[[[language=javascriptvar transformText = function(text, onCompleteCallback) {	var result = text.toUpperCase();	onCompleteCallback(result, text);}transformText('hello', function(newText, originalText) {	// newText == 'HELLO'	// originalText == 'hello'});]]]Using blocks as comparators (sorting by string length)ST[[[language=smalltalkcities := #('Antwerpen' 'Prague' 'Lille').cities sort: [ :a :b | a size < b size ]. "-> #('Lille' 'Prague' 'Antwerpen')"]]]JavaScript[[[language=javascriptvar cities = ['Antwerpen', 'Prague', 'Lille'];cities.sort(function(a, b) { return a.length - b.length; }); // #('Lille' 'Prague' 'Antwerpen')]]]Java[[[language=javaList<String> cities = Arrays.asList("Antwerpen", "Prague", "Lille");Collections.sort(cities, new Comparator<String>() {	@Override	public int compare(String a, String b) {		return a.length() - b.length();	}}); // {"Antwerpen", "Prague", "Lille"}]]]!! Class CreationJava[[[language=javapackage people;class Person {	String name;	double age;	// BEGIN: Accessors	String getName() {		return name;	}	String setName(String name) {		this.name = name;	};	// END: Accessors	// BEGIN: testing	bool isAdult() {		return age > 18;	}		bool isAgeBetween(int min, int max) {		return (age >= lower) && (age <= max);	}	// END: testing}]]]ST[[[language=smalltalkObject subclass: #NameOfSubclass	slots: {#name. #age}	classVariables: {}	package: 'People'"accessing"Person>>name  ^ name"accessing"Person>>name: aName	name := aName"testing"Person>>isAdult	|legalAge|	legalAge := 18.	^ age > legalAge"testing"Person>>isAgeBetween: aMin and: aMax  ^ age between: aMin and: aMax]]]- ==^== is a symbol for return- ==name== variable and methods do not clash-- because you have to send a message to an object, and all instance variables are protected-- do NOT use get/set prefixes- local variables between pipes ==|== (same as inside block earlier)!! Basics of Syntax - CascadeAlso known as fluent interface, but naturally supported in Smalltalk.In Java, he method must always return itself, otherwise you break the chain.Java[[[language=javaclass Person {	String name;	double age;	setName(String name) {		this.name = name;		return this;	}	setAge(double age) {		this.age = age;		return this;	}}Person person = new Person().setName("Ben").setAge(25);]]]In Smalltalk the method can return whatever it wants.[[[language=smalltalkperson := Person new	name: 'Ben';	age: 25;	yourself]]]- ==new== is an unary method that is sent to the ==Person class== object and creates a new instance- the result of the entire statement is the result of the last message send- ==yourself== always returns itself, so the result will be ==Person== even if ==age:== didn't return the object- the default return value is ==self== (the object), cf. ==null== in Java/C++!! Basics of Syntax - if/while- Smalltalk doesn't have special syntax for if, while- Everything is object-oriented!!! ifJava[[[language=javaif (person.getAge() > 18) {	person.chug(beer);} else {	bouncer.kickOut(person);}	]]]ST[[[language=smalltalk(person age > 18) ifTrue: [	person chug: beer] ifFalse: [	bouncer kickOut: person]]]]- ==ifTrue:==, resp. ==ifTrue:ifFalse:==, resp. ==ifFalse:== are regular methods implemented in the ==Boolean==/==True==/==False== objects- arguments are regular blocks (see earlier)!!! whileJava[[[language=javawhile (!earth.isDestroyed()) {	people.produceGarbage();}]]]ST[[[language=smalltalk[ earth isDestroyed not ] whileTrue: [	people produceGarbage]]]]- on every loop the first block is evaluated, and if the result is true, the second block is evaluated- implemented recursively in the ==BlockClosure== class!!! forJava[[[language=javafor (int i = 0; i < 50; ++i) {	...}]]]ST[[[language=smalltalk1 to: 50 do: [ :i |	...]]]]!!! foreachJava[[[language=javafor (Person person : people) {	...}]]]ST[[[language=smalltalkpeople do: [ :person |	...]]]]