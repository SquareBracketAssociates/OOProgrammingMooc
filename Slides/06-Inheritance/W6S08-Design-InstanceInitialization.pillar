{
  "title":"About Instance Initialization",
  "slidesid" : "W3S03"
}

${slide:title=How to ensure that an instance is well initialized?}$

- Automatic initialize
- Lazy initialization
- Proposing the right interface
- Providing a default value

${slide:title=Provider Responsibility}$

- This is the responsibility of the class to provide well-formed object
- A client should not make assumptions or been responsible to send specific sequence of messages to get a working object

${slide:title=A First Implementation of Packet}$

[[[
Object subclass: #Packet
	instanceVariableNames: 'contents addressee originator '

Packet >> printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: ' addressed to: '; nextPutAll: self addressee.
	aStream nextPutAll: ' with contents: '; nextPutAll: self contents
Packet >> addressee
	^addressee
Packet >> addressee: aSymbol
	addressee := aSymbol
]]]

${slide:title=Packet class Definition}$

Packet class is automatically defined
[[[
Packet class
	instanceVariableNames: ''
]]]

Example of instance creation

[[[
Packet new
	addressee: #mac ;
	contents: 'hello mac'
]]]


${slide:title=Fragile Instance Creation}$

- If we do not specify a contents, it breaks!

[[[
| p |
p := Packet new addressee: #mac.
p printOn: aStream
-> error
]]]


${slide:title=Problems}$

- Responsibility of the instance creation relies on the clients
- A client can create packet without contents, without address instance variable not initialized

- error (for example, printOn:)
- system fragile


${slide:title=Fragile Instance Creation Solutions}$

- Automatic initialization of instance variables
- Proposing a solid interface for the creation
- Lazy initialization


${slide:title=Instance Initialization}$

How to ensure that an instance is well initialized?

-Automatic initialize
-Lazy initialization
-Proposing the right interface
-Providing a default value

${slide:title=Assuring Instance Variable Initialization}$

- How to initialize a newly created instance?
- Define the method ==initialize==
[[[
Packet >> initialize
	super initialize.
	contents := ''.
	addressee := #noAd
]]]

${slide:title=The New/Initialize Couple}$

[[[
Object >> initialize
	"do nothing. Called by new my subclasses override me if necessary"
	^ self
]]]



${slide:title=Lazy Initialization}$

- When some instance variables are:
-- not used all the time
-- consuming space, difficult to initialize because depending on other
-- need a lot of computation
- Use lazy initialization based on accessors
- But accessor access should be used consistently!

${slide:title=Lazy Initialization Example}$

A lazy initialization scheme with default value
[[[
Packet >> contents
	contents isNil
		ifTrue: [contents := 'no contents']
	^ contents
]]]

- aPacket contents or self contents
- A lazy initialization scheme with computed value
[[[
Dummy>>ratio
	ratio isNil
		ifTrue: [ratio := self heavyComputation]
]]]

${slide:title=Better}$
[[[
Packet>>contents
	contents isNil
		ifTrue: [contents := 'no contents']
	^ contents
]]]
is equivalent to
[[[
Packet>>contents
	^ contents ifNil: [contents := 'no contents]
]]]




${slide:title=Strengthen Instance Creation Interface}$
- Problem: A client can still create aPacket without address.
- Solution: Force the client to use the class interface creation.
- Providing an interface for creation and avoiding the use of new: Packet send: 'Hello mac' to: #Mac
[[[
Packet class >> send: aString to: anAddress 
	^ self new contents: aString ; addressee: anAddress ; yourself
]]]

${slide:title=Examples of Instance Initialization}$

- Step 1. SortedCollection sortBlock: [:a :b| a name < b name]
[[[
SortedCollection class>>sortBlock: aBlock
	"Answer a new instance of SortedCollection such that its elements are sorted according to the criterion specified in aBlock."
		^ self new sortBlock: aBlock
]]]
- Step 2. self new => aSortedCollection
- Step 3. aSortedCollection sortBlock: aBlock

${slide:title=Another Example}$

- Step 1. OrderedCollection with: 1
[[[
Collection class >> with: anObject
	"Answer a new instance of a Collection containing anObject."
	| newCollection |
	newCollection := self new.
	newCollection add: anObject.
	^newCollection
]]]


${slide:title=Invoking per Default the Creation Interface}$

[[[
OrderedCollection class >> new
	"Answer a new empty instance of OrderedCollection."
	^self new: 5
]]]

${slide:title=Forbidding new?}$
- Problem: We can still use new to create fragile instances
- Solution: new should raise an error!
[[[
Packet class >> new
	self error: 'Packet should only be created using send:to:'
]]]

${slide:title=Forbidding new Implications}$

But we still have to be able to create instance!
[[[
Packet class >> send: aString to: anAddres
	^ self new contents: aString ; addressee: anAddress
]]]

raises an error
[[[
Packet class >> send: aString to: anAddress
	^ super new contents: aString ; addressee: anAddress
]]]

${slide:title=Forbidding new}$

Solution: use ==basicNew== and ==basicNew:==
[[[
Packet class >> send: aString to: anAddress
	^ self basicNew
		contents: aString ;
		addressee: anAddress
]]]

Conclusion: Do not override ==basic*== methods else you will not be able to invoke them later


${slide:title=How to ensure that an instance is well initialized?}$

- Automatic initialize
- Lazy initialization
- Proposing the right interface
- Providing a default value
